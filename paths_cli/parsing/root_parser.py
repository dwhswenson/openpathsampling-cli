from paths_cli.parsing.core import Parser, InstanceBuilder
from paths_cli.parsing.plugins import ParserPlugin

import logging
logger = logging.getLogger(__name__)

class ParserRegistrationError(Exception):
    pass


# TODO: I think this is the only OPS-specific thing in here
_DEFAULT_PARSE_ORDER = [
    'engine',
    'cv',
    'volume',
    'state',
    'network',
    'movescheme',
]

PARSE_ORDER = _DEFAULT_PARSE_ORDER.copy()

def clean_input_key(key):
    # TODO: move this to core
    """
    Canonical approach is to treat everything as lowercase with underscore
    separators. This will make everything lowercase, and convert
    whitespace/hyphens to underscores.
    """
    key = key.lower()
    key = "_".join(key.split())  # whitespace to underscore
    key.replace("-", "_")
    return key

### Managing known parsers and aliases to the known parsers ################

_PARSERS = {}  # mapping: {canonical_name: Parser}
_ALIASES = {}  # mapping: {alias: canonical_name}
# NOTE: _ALIASES does *not* include self-mapping of the canonical names

def _canonical_name(alias):
    """Take an alias or a parser name and return the parser name

    This also cleans user input (using the canonical form generated by
    :meth:`.clean_input_key`).
    """
    alias = clean_input_key(alias)
    alias_to_canonical = _ALIASES.copy()
    alias_to_canonical.update({pname: pname for pname in _PARSERS})
    return alias_to_canonical.get(alias, None)

def _get_parser(parser_name):
    """
    _get_parser must only be used after the parsers have been registered. It
    will automatically create a parser for any unknown ``parser_name.``
    """
    canonical_name = _canonical_name(parser_name)
    # create a new parser if none exists
    if canonical_name is None:
        canonical_name = parser_name
        _PARSERS[parser_name] = Parser(None, parser_name)
    return _PARSERS[canonical_name]

def _register_parser_plugin(plugin):
    DUPLICATE_ERROR = RuntimeError(f"The name {plugin.name} has been "
                                   "reserved by another parser")
    if plugin.name in _PARSERS:
        raise DUPLICATE_ERROR

    parser = _get_parser(plugin.name)

    # register aliases
    new_aliases = set(plugin.aliases) - set([plugin.name])
    for alias in new_aliases:
        if alias in _PARSERS or alias in _ALIASES:
            raise DUPLICATE_ERROR
        _ALIASES[alias] = plugin.name


### Handling delayed loading of parsers ####################################
#
# Many objects need to use parsers to create their input parameters. In
# order for them to be able to access dynamically-loaded plugins, we delay
# the loading of the parser by using a proxy object.

class _ParserProxy:
    def __init__(self, parser_name):
        self.parser_name = parser_name

    @property
    def _proxy(self):
        canonical_name = _canonical_name(self.parser_name)
        if canonical_name is None:
            raise RuntimeError("No parser registered for "
                               f"'{self.parser_name}'")
        return _get_parser(canonical_name)

    @property
    def named_objs(self):
        return self._proxy.named_objs

    def __call__(self, *args, **kwargs):
        return self._proxy(*args, **kwargs)

def parser_for(parser_name):
    """Delayed parser calling.

    Use this when you need to use a parser as the loader for a  parameter.

    Parameters
    ----------
    parser_name : str
        the name of the parser to use
    """
    return _ParserProxy(parser_name)


### Registering builder plugins and user-facing register_plugins ###########

def _get_registration_names(plugin):
    """This is a trick to ensure that the names appear in the desired order.

    We always want the plugin name first, followed by aliases in order
    listed by the plugin creator. However, we only want each name to appear
    once.
    """
    ordered_names = []
    found_names = set([])
    aliases = [] if plugin.aliases is None else plugin.aliases
    for name in [plugin.name] + aliases:
        if name not in found_names:
            ordered_names.append(name)
            found_names.add(name)
    return ordered_names

def _register_builder_plugin(plugin):
    parser = _get_parser(plugin.parser_name)
    for name in _get_registration_names(plugin):
        parser.register_builder(plugin, name)

def register_plugins(plugins):
    builders = []
    parsers = []
    for plugin in plugins:
        if isinstance(plugin, InstanceBuilder):
            builders.append(plugin)
        elif isinstance(plugin, ParserPlugin):
            parsers.append(plugin)

    for plugin in parsers:
        _register_parser_plugin(plugin)

    for plugin in builders:
        _register_builder_plugin(plugin)

### Performing the parsing of user input ###################################

def _sort_user_categories(user_categories):
    """Organize user input categories into parse order.

    "Cateogories" are the first-level keys in the user input file (e.g.,
    'engines', 'cvs', etc.) There must be one Parser per category.
    """
    user_to_canonical = {user_key: _canonical_name(user_key)
                         for user_key in user_categories}
    sorted_keys = sorted(
        user_categories,
        key=lambda x: PARSE_ORDER.index(user_to_canonical[x])
    )
    return sorted_keys

def parse(dct):
    """Main function for compiling user input to objects.
    """
    objs = []
    for category in _sort_user_categories(dct):
        # func = PARSERS[category]
        func = _get_parser(category)
        yaml_objs = dct.get(category, [])
        print(f"{yaml_objs}")
        new = [func(obj) for obj in yaml_objs]
        objs.extend(new)
    return objs
